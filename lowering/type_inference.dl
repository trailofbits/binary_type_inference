.type NodeId <: unsigned
.type ParamIdx <: unsigned
.type TypeConstant <: symbol
.type Bytes <: unsigned 
.type Bits <: unsigned
.type Field = [size: Bits, offset: Bytes]
.type Argument = [idx: ParamIdx]



.decl is_bottom(node_id: NodeId)
.input is_bottom

.decl is_top(node_id: NodeId)
.input is_top

.decl can_load(src_node: NodeId, dst_node: NodeId)
.input can_load

.decl can_store(src_node: NodeId, dst_node: NodeId)
.input can_store

// size in bits offset in bytes
.decl has_field(src_node: NodeId, dst_node: NodeId, size: Bits, offset: Bytes)
.input has_field
.output has_field

.decl in_param(src_node: NodeId, dst_node: NodeId, idx: ParamIdx)
.input in_param

.decl out_param(src_node: NodeId, dst_node: NodeId)
.input out_param


// a node gets associated with a type where the type gets an id
.decl FirstClassType(node: NodeId)
FirstClassType(node) :- Structure(node); Pointer(node, _); Alias(node, _); Scalar(node).

.decl Scalar(node: NodeId)
Scalar(node) :- !is_bottom(node), !is_top(node).

// a type can be a first class type or a function type. Pointers can point to non first class types. This is
// how we support function pointers.
.decl Type(node: NodeId)
Type(node) :- FirstClassType(node).

.decl AllOutgoingFields(src: NodeId)
AllOutgoingFields(src_id) :- !out_param(src_id, _), has_field(src_id, _, _, _),
    !in_param(src_id, _, _), !out_param(src_id, _), !can_store(src_id, _), !can_load(src_id, _).


.decl HasField(fld: Field, src_id: NodeId, dst_type: NodeId)
HasField([size, offset], src_node, dst_node) :- has_field(src_node, dst_node, size, offset).


.decl IncompatibleFields(f1: Field, f2: Field, src_node: NodeId)
IncompatibleFields([f1_sz, f1_offset], [f2_sz, f2_offset], src_node) :-
    HasField([f1_sz, f1_offset], src_node, dst_node1),
    HasField([f2_sz, f2_offset], src_node, dst_node2),
    dst_node1 != dst_node2, // this isnt totally correct because we could have multiple fields going to the same node that are incompatible??
        (
        (f1_offset < f2_offset) ,  (f1_offset + f1_sz > f2_offset);
        (f2_offset < f1_offset), (f2_offset + f2_sz > f1_offset)
        ).

.decl CompatibleStructure(node: NodeId)
CompatibleStructure(node) :- 
    AllOutgoingFields(node), !IncompatibleFields(_, _, node), HasField(_, node, _).

.decl MultiFieldStructure(node: NodeId)
MultiFieldStructure(node) :- HasField(_, node, dst_node1), HasField(_,node, dst_node2), dst_node1 != dst_node2.

.decl Structure(node: NodeId)
Structure(node) :- MultiFieldStructure(node), CompatibleStructure(node).

// Catch one field structs as type aliases
.decl Alias(node: NodeId, tgt: NodeId)
Alias(node, tgt) :- !MultiFieldStructure(node), CompatibleStructure(node), HasField(_, node, tgt), FirstClassType(tgt).

.decl Pointer(node: NodeId, tgt: NodeId)
Pointer(node, tgt) :- can_load(node, tgt).