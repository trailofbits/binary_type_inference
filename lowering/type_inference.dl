.type NodeId <: unsigned
.type ParamIdx <: unsigned
.type TypeConstant <: symbol
.type Bytes <: unsigned 
.type Bits <: unsigned
.type Field = [size: Bits, offset: Bytes]
.type Argument = [idx: ParamIdx]



.decl node(node_id: NodeId)
.input node

.decl is_bottom(node_id: NodeId)
.input is_bottom

.decl  primitive(node_id: NodeId, name: symbol)
.input primitive
.output primitive(headers=true)

.decl is_top(node_id: NodeId)
.input is_top

.decl can_load(src_node: NodeId, dst_node: NodeId)
.input can_load

.decl can_store(src_node: NodeId, dst_node: NodeId)
.input can_store

// size in bits offset in bytes
.decl has_field(src_node: NodeId, dst_node: NodeId, size: Bits, offset: Bytes)
.input has_field

.decl in_param(src_node: NodeId, dst_node: NodeId, idx: ParamIdx)
.input in_param
.output in_param(headers=true)

.decl out_param(src_node: NodeId, dst_node: NodeId)
.input out_param
.output out_param(headers=true)
// TODO(ian): make this an input with an edge id, then we can do implication without tons of negation by
// creating a relation like only stores, !edge(src, _, id) where !can_store(id) fixes a lot of code duplication
// Edge properties would be attached to the edge id
.decl edge(src_node: NodeId, dst_node: NodeId)
edge(src_node, dst_node) :- 
    can_load(src_node, dst_node);
    can_store(src_node, dst_node);
    has_field(src_node, dst_node, _, _);
    in_param(src_node, dst_node, _);
    out_param(src_node, dst_node).


.decl NonAliasedFirstClassType(node: NodeId)
NonAliasedFirstClassType(node) :- Structure(node); Pointer(node, _); Scalar(node).

// a node gets associated with a type where the type gets an id
.decl FirstClassType(node: NodeId)
FirstClassType(node) :- NonAliasedFirstClassType(node); Alias(node, _).

.decl Scalar(node: NodeId)
Scalar(node) :- !is_bottom(node), !is_top(node), node(node).

// a type can be a first class type or a function type. Pointers can point to non first class types. This is
// how we support function pointers.
.decl ComplexType(node: NodeId)
ComplexType(node) :- FirstClassType(node); Function(node).



.decl ConflictingOut(node: NodeId)
ConflictingOut(node) :- out_param(node, d1), out_param(node, d2), d1 != d2.

.decl ConflictingIn(node: NodeId)
ConflictingIn(node) :- in_param(node, tgt1, idx1), in_param(node, tgt2, idx2), tgt1 != tgt2, idx1 = idx2.

.decl Function(node: NodeId)
Function(node) :-
    AllOutgoingAreOutsOrIns(node), !ConflictingOut(node), !ConflictingIn(node).
.output Function(headers=true)

.decl AllOutgoingAreOutsOrIns(node: NodeId)
AllOutgoingAreOutsOrIns(src_node) :- 
    (out_param(src_node, _); in_param(src_node, _, _)),
    !can_load(src_node, _),
    !can_store(src_node, _),
    !has_field(src_node, _, _, _).

.decl AllOutgoingFields(src: NodeId)
AllOutgoingFields(src_id) :- has_field(src_id, _, _, _),
    !in_param(src_id, _, _), !out_param(src_id, _), !can_store(src_id, _), !can_load(src_id, _).

.decl HasField(fld: Field, src_id: NodeId, dst_type: NodeId)
HasField([size, offset], src_node, dst_node) :- has_field(src_node, dst_node, size, offset).


.decl IncompatibleFields(f1: Field, f2: Field, src_node: NodeId)
IncompatibleFields([f1_sz, f1_offset], [f2_sz, f2_offset], src_node) :-
    HasField([f1_sz, f1_offset], src_node, dst_node1),
    HasField([f2_sz, f2_offset], src_node, dst_node2),
    dst_node1 != dst_node2, // this isnt totally correct because we could have multiple fields going to the same node that are incompatible??
        (
        ((f1_offset < f2_offset) ,  (f1_offset + (f1_sz/8) > f2_offset));
        ((f2_offset < f1_offset), (f2_offset + (f2_sz/8) > f1_offset));
        f1_offset = f2_offset
        ).

    
.decl CompatibleStructure(node: NodeId)
CompatibleStructure(node) :- 
    AllOutgoingFields(node), !IncompatibleFields(_, _, node), HasField(_, node, _).

.decl MultiFieldStructure(node: NodeId)
MultiFieldStructure(node) :- HasField(_, node, dst_node1), HasField(_,node, dst_node2), dst_node1 != dst_node2.

.decl StructureField(node: NodeId, size: Bits, offset: Bytes, child_type: NodeId)
StructureField(node, size, offset, child_type) :- Structure(node), HasField([size,offset],node, child_type), FirstClassType(child_type).
.output StructureField(headers=true)

// TODO(ian): right now we are checking that just one field has a type we need to check that all fields have a type.
// This is going to be really annoying 
.decl FieldWithoutType(node: NodeId)
FieldWithoutType(node) :- node(node), HasField(_, node, tgt), FirstClassType(tgt).

.decl Structure(node: NodeId)
Structure(node) :- MultiFieldStructure(node), CompatibleStructure(node), FieldWithoutType(node).
.output Structure(headers=true)

.decl HasUntypedOutgoingEdge(node: NodeId)
HasUntypedOutgoingEdge(node) :- edge(node, tgt), !ComplexType(tgt).

.decl AllChildrenTyped(node: NodeId)
AllChildrenTyped(node) :- !HasUntypedOutgoingEdge(node), node(node).

.decl Type(node: NodeId)
Type(node) :- AllChildrenTyped(node), ComplexType(node).
.output Type(headers=true)

.decl NodesCanBeAliased(node: NodeId, tgt: NodeId)
NodesCanBeAliased(node, tgt) :- !MultiFieldStructure(node), CompatibleStructure(node), HasField(_, node, tgt).
NodesCanBeAliased(node, tgt) :- NodesCanBeAliased(tgt, node).
NodesCanBeAliased(node, tgt) :- NodesCanBeAliased(node, mid), NodesCanBeAliased(mid, tgt).

// Catch one field structs as type aliases
.decl Alias(node: NodeId, tgt: NodeId)
Alias(node, tgt) :- NodesCanBeAliased(node, tgt), FirstClassType(tgt), NonAliasedFirstClassType(tgt), node != tgt.
.output Alias(headers=true)


.decl OnlyOutgoingStoresAndLoads(node: NodeId)
OnlyOutgoingStoresAndLoads(node) :- (can_load(node, _); can_store(node, _)),
    !has_field(node, _, _, _),
    !in_param(node, _, _),
    !out_param(node, _).

// TODO(ian): make this recursive to check all the way down a chain of aliases
.decl NotEqualTypes(node1: NodeId, node2: NodeId)
NotEqualTypes(node1, node2) :-
   node1 != node2, !NodesCanBeAliased(node1, node2), !NodesCanBeAliased(node2, node1), node(node1), node(node2).

.decl HasOutgoingEdgesToDifferentTypes(node: NodeId)
HasOutgoingEdgesToDifferentTypes(node) :- 
    edge(node, dst_node1),
    edge(node, dst_node2),
    NotEqualTypes(dst_node1, dst_node2).

.decl Pointer(node: NodeId, tgt: NodeId)
Pointer(node, tgt) :- (can_load(node, tgt); can_store(node, tgt)), !HasOutgoingEdgesToDifferentTypes(node), OnlyOutgoingStoresAndLoads(node), ComplexType(tgt).
.output Pointer(headers=true)